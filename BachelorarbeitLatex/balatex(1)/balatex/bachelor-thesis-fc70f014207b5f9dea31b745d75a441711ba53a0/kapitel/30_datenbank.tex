
\chapter{The Database}
The following chapter is devoted to creating the Firestore database for the application. For this purpose, the JSON data records provided by the ApiMedic API are examined more closely in order to be able to design a database structure. After the successful data conception, the data sets are integrated into Firestore via a Python script. This procedure is also documented using a notebook (Jupyter Notebook) and is described there in more detail.

\section{Data Structure}
The data structure of the database is based on the decision that the ApiMedic API will be the main supplier of the data. The basic data structure can already be guessed from the domain model, which is shown in Figure 4.4. Firestore supports the following datatypes: String, Number, Boolean, Map, Array, Null, Timestamp, Geopoint and Reference. With a closer look at the API's JSON responses, the data structures can be formed.

\subsection{Examination of the JSON-Structure of ApiMedic}
ApiMedic does not provide any actual documentation. Instead, they give interested users the opportunity to test the HTTP requests directly via the ApiMedic website. To access the API, a HTTP request must be sent. The URL of the endpoint, the HTTP method and, if necessary, other parameters and headers must be specified. All inquiries can be made via a request to the following URL: \textbf{https://healthservice.priaid.ch/} in connection with the corresponding path to the desired file resource. The API responses can then be extracted from the HTTP message body in the form of a JSON object.

\subsubsection{Body Part}
\begin{itemize}
	\item \textbf{Get all Body Regions:  /body/locations?token=\{your\_token\}}
	\newline
	If the request is successful (status code 200), all body regions that are stored in the API form the output.
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Field& Content & Datatype \\ 
  				\hline
  				ID & ID of the body region & Integer \\ 
  				\hline
 				Name & Name of the body region & String \\ 
  				\hline
			\end{tabular}
		\end{center}
With the help of the ID of the body regions, the individual body parts of a region can be determined.
	\item \textbf{Get all Body Parts:  /body/locations/\{body\_region\_id\}?token=\{your\_token\}}
	\newline
If the request is successful (status code 200), all body locations that are stored in the API form the output.
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Field& Content & Datatype \\ 
  				\hline
  				ID & ID of the body location & Integer \\ 
  				\hline
 				Name & Name of the body location & String \\ 
  				\hline
			\end{tabular}
		\end{center}
	\item \textbf{Get all Body Parts:  /body/locations/\{body\_region\_id\}/\{gender\_id\}?token=\{your\_token\}}
	\newline
If the request is successful, all body locations that are stored in the API form the output. The IDs of the genders are values ranging from 0 to 3. 
		\begin{center}
		\scriptsize
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Field& Content & Datatype \\ 
  				\hline
  				ID & ID of the symptom & Integer \\ 
  				\hline
 				Name & Name of the symptom & String \\ 
  				\hline
  				HasRedFlag & Indicates whether the symptom has been classified as critical & Boolean \\ 
  				\hline
  				HealthSymptomLocationIDs & IDs of the body locations that are affected by this symptom & Array[Integer] \\ 
  				\hline
 				ProfName & Professional name of the symtom & String \\
				\hline 			
 				Synonyms & Synonyms of the symptom & Array[String] \\
 				\hline
			\end{tabular}
		\normalsize
		\end{center}

\end{itemize}
Instead of storing all body areas, all explicit body parts and their possible symptoms will be stored in Firestore. Based on the information obtained from successful HTTP requests, the Firestore structure can be defined as shown below.
\newline
\textbf{Collection: body\_parts}
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Document-field& Content & Datatype \\ 
  				\hline
  				name & Name of the body part & String \\ 
  				\hline
 				symptoms & List of all symptom ids of the body part  & Array[String] \\ 
  				\hline
			\end{tabular}
		\end{center}
The ids of the documents are formed from the name of the respective object. Here, spaces are simply replaced by a "\_" and the name string is stripped of leading and trailing spaces using the Python function .strip(). The id generation method should never be used for real world applications. However, it simplifies the legibility in the context of this bachelor thesis. Firestore saves all the data in form of documents which can be created using .doc(\{document\_id\}).set(\{...\}).  When performing this operation, the document is automatically assigned the specified ID, making it unnecessary to store the id in the document itself.

\subsubsection{Ressource Symptom}
\begin{itemize}
		\item \textbf{Get all Symptoms :  /symptoms?token=\{your\_token\}}
\newline		
If the request is successful, all symptoms that are stored in the API form the output.
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Field& Content & Datatype \\ 
  				\hline
  				ID & ID of the symptom & Integer \\ 
  				\hline
 				Name & Name of the symptom & String \\ 
  				\hline
			\end{tabular}
		\end{center}

\item \textbf{Get all proposed Symptoms:  /symptoms/proposed?symptoms=[\{symptom\_ids\}]\newline\&gender=\{gender\_name\}\&year\_of\_birth=\{birthyear\_YYYY\}?token=\{your\_token\}}
\newline
Unlike the query regarding all symptoms of a body part, the values of the genders are not to be given as an ID, but in the form of full names, i. e. "male" and "female".
	\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Field& Content & Datatype \\ 
  				\hline
  				ID & ID of the proposed symptom & Integer \\ 
  				\hline
 				Name & Name of the proposed symptom & String \\ 
  				\hline
			\end{tabular}
		\end{center}
\end{itemize}
Since all ids of the symptoms for each body part are already stored in each body part document, there is no need to add the body part ids to the symptom anymore. Because of that, all that is needed to be stored is the name of the symptom and the ids of the proposed symptoms.
\newline
\textbf{Collection: symptoms}
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Document-field& Content & Datatype \\ 
  				\hline
  				name & Name of the body part & String \\ 
  				\hline
 				proposed\_symptoms & List of all proposed symptoms ids of the symptom  & Array[String] \\ 
  				\hline
			\end{tabular}
		\end{center}
\subsubsection{Ressource Disease}
\begin{itemize}
	\item \textbf{Get all issues (diseases):  /issues?token=\{your\_token\}}
	\newline
	If the request is successful (status code 200), all diseases that are stored in the API form the output.
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Field& Content & Datatype \\ 
  				\hline
  				ID & ID of the body region & Integer \\ 
  				\hline
 				Name & Name of the body region & String \\ 
  				\hline
			\end{tabular}
		\end{center}
With the help of the ID of the body regions, the individual disease can be determined.
	\item \textbf{Get a single issue:  /issues/\{issue\_id\}?token=\{your\_token\}}
	\newline
If the request is successful (status code 200), the requested issue forms the output.
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Field& Content & Datatype \\ 
  				\hline
  				Description & Description of the disease & String \\ 
  				\hline
 				DescriptionShort & Short description of the disease & String \\ 
  				\hline
  				MedicalCondition & Description of the symptoms & String \\ 
  				\hline
  				Name & Name of the disease & String \\ 
  				\hline
  				PossibleSymptoms & All symptoms of the disease, comma separated string & String \\ 
  				\hline
  				ProfName & Professional name of the disease & String \\ 
  				\hline
  				Synonyms & Synonyms of the disease & String \\ 
  				\hline
  				Treatment & Treatment steps for the disease & String \\
  				\hline 
			\end{tabular}
		\end{center}
\end{itemize}
The resources provided by the issues are stored in the Firestore database under the diseases collection. For the purposes of the work, only the name, description, symptoms and treatment recommendation are extracted and stored.
\newline
\textbf{Collection: diseases}
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Document-field& Content & Datatype \\ 
  				\hline
  				name & Name of the body part & String \\ 
  				\hline
 				description & List of all symptom ids & Array[String] \\ 
  				\hline
  				treatment & Treatment recomendation of the disease & String \\ 
  				\hline
			\end{tabular}
		\end{center}
\subsubsection{Advice}
The advice generated by doctors is not part of the ApiMedic API data resources. They are created directly by users (doctors) of the application and require a title, description, associated symptoms and associated diseases. Taken together, this results in the document structure shown in Table x.x.
\textbf{Collection: advices}
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Document-field& Content & Datatype \\ 
  				\hline
  				name & Title of the advice& String \\ 
  				\hline
 				description & Description of the advice & String \\ 
  				\hline
  				symptoms & List of associated symptom ids & Array[String]\\ 
  				\hline
  				diseases & List of associated disease ids & Array[String]\\ 
  				\hline
			\end{tabular}
		\end{center}
\subsubsection{Doctor}
Doctors have the opportunity to register with the database. To do this they will be asked to enter an email and a password. Firestore allows all of this to happen without involving a dedicated collection of users. Nevertheless, it makes sense to do this, since user data could possibly be expanded at a later date. An example of this is that records added by a doctor should also be referenced in his account. This requires a collection that stores the user data of the respective doctor in separate documents. The user ID is automatically generated by Firestore in the form of a hash value during registration.
\textbf{Collection: doctors}
		\begin{center}
			\begin{tabular}{ | c| c| c | } 
  				\hline
  				Name of Document-field& Content & Datatype \\  
  				\hline
  				email & E-Mail-Adress of the doctor & String \\
  				\hline
			\end{tabular}
		\end{center}
\subsubsection{User, User Specified Symptom, Diagnose, SymptomIntensity and NovelityFactor}
The user-defined symptoms are not stored in the database, but are only generated temporarily and locally in the system during the diagnosis. The reason for not saving the user-specific symptoms is that a user does not have to log in to the application and therefore no user document is created in the database through which the symptoms could be traced back to the user. Only the individual attributes of the object are stored in the diagnosis in order to be able to understand the diagnosis when it is called up again. The classes users and diagnoses, as well as the enumerations symptoms intensity and novelty factor will not be stored in the database, but will be, too, modeled internally in the system. There, the diagnoses are to be stored locally on the smartphone, which ensures that no personal data of the user is stored in the database.

\section{Inserting the Data into the Database and connecting the Database with the Flutter Project}
Adding the records to the database requires a few steps, which have been summarized with the help of Jupyter Notebook. The notebook can be downloaded by following the link of the QR code in the appendix x. After the successful data generation, the database can now be integrated into the application. For this, the scheme provided by the Flutter developers is followed.